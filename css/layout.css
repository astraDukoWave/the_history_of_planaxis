/* ============================================================================
   LAYOUT.CSS - Base Estructural con CSS Grid y Flexbox
   
   ¿POR QUÉ? Este archivo establece la estructura fundamental de la página y utilidades
   de layout reutilizables. Al separar la lógica de layout del estilizado visual, podemos
   cambiar colores/fuentes sin romper la estructura.
   
   ¿CÓMO FUNCIONA? Usamos CSS Grid para el layout general de página (header, main, footer)
   y Flexbox para alineación a nivel de componente (centrado, distribución).
   
   ANALOGÍA FEYNMAN: Piensa en construir una casa. Este archivo es como la estructura:
   vigas, columnas, cimientos. Los otros archivos CSS son la decoración: pintura, muebles.
   Si cambias el color de las paredes (visual), la estructura permanece igual.
   
   RESULTADO: Una base robusta y flexible que se adapta a cambios de contenido.
   ============================================================================ */

/* ¿POR QUÉ? El body es el contenedor raíz para todo el contenido visible. Establecer
   propiedades específicas de fuente y color aquí asegura consistencia en toda la página.
   
   ¿CÓMO FUNCIONA? Todos los elementos hijos heredan estos valores a menos que se
   sobrescriban explícitamente. Estamos estableciendo nuestra tipografía y esquema de
   color base.
   
   RESULTADO: Cada elemento de texto por defecto es texto blanco sobre fondo oscuro con
   el stack de fuentes del sistema, creando consistencia inmediata. */
body {
  font-family: var(--font-primary);
  background-color: var(--color-bg-primary);
  color: var(--color-text-main);
  font-size: var(--font-size-base);
  font-weight: var(--font-weight-normal);
  
  /* ¿POR QUÉ? Deshabilitamos la selección de texto en el body para prevenir resaltados
     azules extraños cuando los usuarios accidentalmente arrastran sobre navegación o
     elementos de UI. Sin embargo, áreas de contenido real (como párrafos) deben
     re-habilitar esto.
     
     ¿CÓMO FUNCIONA? user-select: none previene que el cursor seleccione texto.
     
     RESULTADO: Interacción de UI más limpia, aunque re-habilitaremos la selección para
     secciones de contenido legible. */
  -webkit-user-select: none;
  -moz-user-select: none;
  user-select: none;
}

/* ¿POR QUÉ? Las áreas de contenido principal deben permitir selección de texto para
   copiar información importante. Sobrescribimos el user-select: none del body
   específicamente para contenido principal.
   
   ¿CÓMO FUNCIONA? El elemento main representa el contenido primario de la página.
   
   RESULTADO: Los usuarios pueden seleccionar y copiar contenido real, pero no chrome de UI. */
main {
  -webkit-user-select: text;
  -moz-user-select: text;
  user-select: text;
}

/* ============================================================================
   SISTEMA DE CONTENEDORES
   
   ¿POR QUÉ? Las pantallas anchas (como monitores de 27") hacen que leer sea incómodo
   si el texto se estira por todo el ancho. La longitud de línea óptima es 50-75 caracteres.
   
   ¿CÓMO FUNCIONA? Creamos clases contenedoras que restringen el ancho del contenido
   y lo centran.
   
   ANALOGÍA FEYNMAN: Es como leer un libro vs leer en una pizarra gigante. El libro
   tiene columnas del ancho perfecto. La pizarra es demasiado ancha - tus ojos se
   cansan yendo de izquierda a derecha. Los contenedores hacen "columnas" del ancho
   perfecto incluso en pantallas gigantes.
   ============================================================================ */

/* ¿POR QUÉ? CENTRADO PERFECTO con Conciencia del Dock Flotante - El contenedor debe
   estar centrado mientras también crea una zona segura para el Dock de Vidrio Flotante
   a la derecha.
   
   ESTRATEGIA DE DISEÑO: En lugar de padding asimétrico (que rompe el centrado), usamos
   un max-width más estrecho (1100px en lugar de 1200px) y centrado perfecto. Esto
   crea espacio de respiración natural en ambos lados, asegurando que el dock flote
   sobre espacio blanco sin obstruir contenido.
   
   ¿CÓMO FUNCIONA? margin-inline: auto (CSS moderno) centra el contenedor perfectamente.
   max-width restringe el ancho del contenido. Width 90% asegura espaciado en móviles.
   
   RESULTADO: Contenido simétricamente centrado con espaciado igual en ambos lados, y
   suficiente espacio del lado derecho para que el Dock de Vidrio Flotante flote cómodamente. */
.container {
  /* ¿POR QUÉ? width: 90% asegura que el contenido no toque los bordes de la pantalla
     en dispositivos móviles mientras es responsivo a diferentes tamaños de viewport.
     
     ¿CÓMO FUNCIONA? 90% de ancho deja 5% de espacio de respiración en cada lado en
     pantallas pequeñas.
     
     RESULTADO: El contenido tiene espaciado cómodo en todos los dispositivos. */
  width: 90%;
  
  /* ¿POR QUÉ? max-width: 1100px (reducido de 1200px) asegura que el contenido permanezca
     dentro de un ancho legible mientras crea espacio natural para el Dock de Vidrio Flotante.
     
     CÁLCULO ESTRATÉGICO: Contenido de 1100px + dock (60px colapsado / 280px expandido)
     + espaciado = balance perfecto en pantallas típicas (1366px, 1440px, 1920px).
     
     ¿CÓMO FUNCIONA? Max-width previene que el contenido exceda este valor incluso si
     el viewport es más ancho.
     
     RESULTADO: El contenido nunca se vuelve incómodamente ancho, y el dock siempre
     tiene espacio para flotar sin obstrucción. */
  max-width: 1100px;
  
  /* ¿POR QUÉ? margin-inline: auto es LA PROPIEDAD CRÍTICA para centrado horizontal.
     Es la forma moderna en CSS de centrar elementos de bloque (equivalente a margin: 0 auto).
     
     ¿CÓMO FUNCIONA? "inline" se refiere al eje horizontal. "auto" en ambos lados
     distribuye el espacio restante equitativamente, logrando centrado perfecto.
     
     ANALOGÍA FEYNMAN: Es como poner un cuadro en una pared. "auto" en ambos lados es
     como tener resortes invisibles que empujan con igual fuerza desde izquierda y
     derecha - el cuadro naturalmente queda en el centro perfecto.
     
     RESULTADO: El contenedor está perfectamente centrado con espaciado igual a
     izquierda y derecha, creando balance visual y armonía. */
  margin-inline: auto;
  
  /* ¿POR QUÉ? Padding mínimo uniforme previene que el contenido toque los bordes
     mientras mantiene el centrado. Usamos padding pequeño en lugar de padding
     asimétrico grande para preservar el balance.
     
     ¿CÓMO FUNCIONA? var(--spacing-md) aplica 24px de padding en ambos lados equitativamente.
     
     RESULTADO: El contenido tiene espacio de respiración sin romper el layout centrado. */
  padding-left: var(--spacing-md);
  padding-right: var(--spacing-md);
}

/* ¿POR QUÉ? Algunas secciones necesitan abarcar el ancho completo (como imágenes
   full-bleed o colores de fondo) incluso si su contenido está contenido.
   
   ¿CÓMO FUNCIONA? width: 100% explícitamente hace que el elemento llene su contenedor padre.
   
   RESULTADO: Secciones de ancho completo para impacto visual dramático. */
.container-fluid {
  width: 100%;
  padding-left: var(--spacing-md);
  padding-right: var(--spacing-md);
  
  /* ¿POR QUÉ? Incluso los contenedores fluidos se benefician de contenido centrado
     cuando contienen texto o elementos estructurales.
     
     ¿CÓMO FUNCIONA? margin-inline: auto con width: 100% centra cualquier hijo restringido.
     
     RESULTADO: Secciones de ancho fluido con contenido interno correctamente centrado. */
  margin-inline: auto;
}

/* ============================================================================
   UTILIDADES FLEXBOX
   
   ¿POR QUÉ? Flexbox es la forma más eficiente de alinear elementos en una sola
   dirección (horizontalmente o verticalmente). Estas clases de utilidad eliminan
   código repetitivo.
   
   ¿CÓMO FUNCIONA? Creamos clases reutilizables que aplican patrones comunes de flexbox.
   
   GLOSARIO: Flexbox = "Caja Flexible". Un sistema de layout que organiza elementos
   en una fila o columna con superpoderes: centrado automático, distribución de espacio,
   cambio de orden, etc. Piensa en organizar libros en un estante inteligente.
   ============================================================================ */

/* ¿POR QUÉ? Centrar contenido (tanto horizontal como verticalmente) es extremadamente
   común en diseño web - secciones hero, tarjetas, modals, etc.
   
   ¿CÓMO FUNCIONA? display: flex activa flexbox. justify-content: center centra hijos
   a lo largo del eje principal (horizontal por defecto), y align-items: center hace
   lo mismo para el eje cruzado (vertical).
   
   ANALOGÍA FEYNMAN: Es como tener un marco con imanes invisibles que empujan tu
   contenido exactamente al centro desde todas las direcciones. No importa el tamaño
   del contenido - siempre queda perfectamente centrado.
   
   RESULTADO: Centrado perfecto con solo una clase, sin cálculos de margin necesarios. */
.flex-center {
  display: flex;
  justify-content: center;
  align-items: center;
}

/* ¿POR QUÉ? Las barras de navegación típicamente tienen contenido dividido entre
   izquierda y derecha (logo a la izquierda, menú a la derecha).
   
   ¿CÓMO FUNCIONA? space-between distribuye hijos para que el primer elemento esté al
   inicio, el último elemento al final, y el espacio restante se distribuya equitativamente
   entre ellos.
   
   RESULTADO: Espaciado automático que se adapta al tamaño del contenido - perfecto para headers. */
.flex-between {
  display: flex;
  justify-content: space-between;
  align-items: center;
}

/* ¿POR QUÉ? A veces queremos elementos espaciados equitativamente con espacio en los
   lados también, como un conjunto de botones distribuidos uniformemente.
   
   ¿CÓMO FUNCIONA? space-around da a cada elemento espacio igual en ambos lados,
   creando distribución uniforme incluyendo los bordes.
   
   RESULTADO: Espaciado visualmente balanceado a través de todo el contenedor. */
.flex-around {
  display: flex;
  justify-content: space-around;
  align-items: center;
}

/* ¿POR QUÉ? Los layouts verticales (como sidebars o tarjetas apiladas) necesitan
   flex-direction: column. Sin esto, flex por defecto es layout horizontal en fila.
   
   ¿CÓMO FUNCIONA? flex-direction: column hace que el eje principal sea vertical en
   lugar de horizontal.
   
   RESULTADO: Los elementos se apilan de arriba hacia abajo en lugar de izquierda a derecha. */
.flex-column {
  display: flex;
  flex-direction: column;
}

/* ============================================================================
   UTILIDADES CSS GRID
   
   ¿POR QUÉ? CSS Grid es superior para layouts bidimensionales (filas Y columnas
   simultáneamente). Es perfecto para la estructura general de página.
   
   ¿CÓMO FUNCIONA? Definimos templates de grid que crean layouts predecibles.
   
   GLOSARIO: Grid = "Cuadrícula". Como una tabla de Excel pero para layout. Defines
   filas y columnas, y colocas elementos en las celdas. Mucho más poderoso que tables HTML.
   ============================================================================ */

/* ¿POR QUÉ? Un grid estándar de 12 columnas proporciona flexibilidad para layouts
   complejos mientras mantiene alineación. Es divisible por 2, 3, 4 y 6, haciéndolo versátil.
   
   ¿CÓMO FUNCIONA? repeat(12, 1fr) crea 12 columnas de ancho igual. "fr" significa
   "fracción" y distribuye el espacio disponible proporcionalmente.
   
   RESULTADO: Un grid flexible que puede acomodar cualquier combinación de layout
   (6+6 columnas, 4+4+4, 3+3+3+3, etc.). */
.grid-12 {
  display: grid;
  grid-template-columns: repeat(12, 1fr);
  gap: var(--spacing-md);
}

/* ¿POR QUÉ? Muchos layouts necesitan columnas iguales (como una sección de características
   de 3 columnas).
   
   ¿CÓMO FUNCIONA? repeat(3, 1fr) crea 3 columnas de ancho igual. auto-fit permite que
   las columnas se envuelvan a la siguiente fila si el contenedor es muy estrecho.
   
   RESULTADO: Columnas responsivas que automáticamente se ajustan al espacio disponible. */
.grid-auto {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
  gap: var(--spacing-lg);
}

/* ============================================================================
   POSICIONAMIENTO & Z-INDEX
   
   ¿POR QUÉ? Ciertos elementos (navegación, sidebar) necesitan quedarse en su lugar
   mientras el usuario hace scroll. También necesitamos un orden de apilamiento claro
   para elementos superpuestos.
   ============================================================================ */

/* ¿POR QUÉ? Los headers típicamente necesitan permanecer visibles mientras se hace
   scroll (navegación sticky), pero para este diseño queremos que se superponga a la
   imagen hero.
   
   ¿CÓMO FUNCIONA? position: relative establece un contexto de posicionamiento para
   hijos absolutos. z-index asegura que el header permanezca encima de otro contenido.
   
   RESULTADO: El header proporciona un punto de referencia para hijos posicionados
   absolutamente y mantiene el orden de apilamiento correcto. */
.relative {
  position: relative;
}

/* ¿POR QUÉ? Los elementos fixed permanecen en la misma posición relativa al viewport,
   incluso cuando se hace scroll. Esto es esencial para sidebars y navegación sticky.
   
   ¿CÓMO FUNCIONA? position: fixed remueve el elemento del flujo normal del documento
   y lo posiciona relativo al viewport.
   
   ANALOGÍA FEYNMAN: Es como poner una nota adhesiva en tu monitor. Sin importar qué
   desplaces en la pantalla (scroll), la nota adhesiva permanece en el mismo lugar en
   tu monitor - no se mueve con el contenido.
   
   RESULTADO: Elementos que siguen al usuario mientras hacen scroll, manteniendo visibilidad. */
.fixed {
  position: fixed;
}

/* ============================================================================
   UTILIDADES DE ESPACIADO
   
   ¿POR QUÉ? Ajustes rápidos de espaciado sin escribir CSS personalizado para cada
   elemento. Estas utilidades siguen nuestro sistema de espaciado de 8px.
   ============================================================================ */

/* ¿POR QUÉ? El espaciado vertical entre secciones es crucial para el ritmo visual.
   Diferentes tipos de sección necesitan diferentes cantidades de espaciado.
   
   ¿CÓMO FUNCIONA? Creamos clases de utilidad para necesidades comunes de espaciado,
   usando nuestras variables de escala de espaciado para consistencia.
   
   RESULTADO: Ritmo vertical consistente a través de toda la página sin clases personalizadas. */
.section-spacing {
  padding-top: var(--spacing-2xl);
  padding-bottom: var(--spacing-2xl);
}

.mt-lg {
  margin-top: var(--spacing-lg);
}

.mb-lg {
  margin-bottom: var(--spacing-lg);
}

.my-lg {
  margin-top: var(--spacing-lg);
  margin-bottom: var(--spacing-lg);
}

/* ============================================================================
   UTILIDADES DE TEXTO
   
   ¿POR QUÉ? Las alineaciones comunes de texto se usan en todo el diseño. Crear
   utilidades reduce repetición y mantiene el HTML semántico.
   ============================================================================ */

/* ¿POR QUÉ? Diferentes tipos de contenido necesitan diferente alineación - los
   encabezados a menudo centran, el texto del cuerpo se alinea a la izquierda,
   los números se alinean a la derecha.
   
   ¿CÓMO FUNCIONA? text-align es una propiedad CSS simple que controla la alineación horizontal.
   
   RESULTADO: Control rápido de alineación sin estilos inline o clases personalizadas. */
.text-center {
  text-align: center;
}

.text-left {
  text-align: left;
}

.text-right {
  text-align: right;
}

/* ¿POR QUÉ? Algunas secciones necesitan texto blanco incluso si otros estilos lo
   sobrescribirían.
   
   ¿CÓMO FUNCIONA? La bandera !important asegura que este color tome precedencia sobre
   otros estilos. (Nota: ¡Usa con moderación! Solo para clases de utilidad genuinas.)
   
   RESULTADO: Texto blanco garantizado cuando sea necesario, independientemente de
   estilos en cascada. */
.text-white {
  color: var(--color-text-main) !important;
}

/* ¿POR QUÉ? La información secundaria (leyendas, metadatos) debe estar visualmente
   des-enfatizada para crear jerarquía.
   
   ¿CÓMO FUNCIONA? Usando nuestro color de texto apagado (gris-azul) reduce el peso visual.
   
   RESULTADO: Distinción clara entre información primaria y secundaria. */
.text-muted {
  color: var(--color-text-muted);
}

/* ============================================================================
   UTILIDADES DE VISIBILIDAD
   
   ¿POR QUÉ? El diseño responsivo a menudo requiere ocultar elementos en ciertos
   tamaños de pantalla.
   
   ¿CÓMO FUNCIONA? display: none remueve el elemento del layout completamente
   (no se reserva espacio).
   
   RESULTADO: Visibilidad condicional limpia sin JavaScript.
   ============================================================================ */

/* ¿POR QUÉ? A veces necesitamos ocultar contenido visualmente pero mantenerlo accesible
   para lectores de pantalla (como labels de íconos o enlaces de skip navigation).
   
   ¿CÓMO FUNCIONA? Esta técnica recorta el elemento a 1x1 píxel, lo posiciona fuera
   de pantalla y oculta overflow, haciéndolo invisible pero todavía en el DOM.
   
   ANALOGÍA FEYNMAN: Es como susurrar algo tan bajito que solo alguien con audífonos
   especiales (lectores de pantalla) puede oírlo. Las personas viendo la pantalla no
   ven nada, pero el contenido está ahí para quien lo necesite.
   
   RESULTADO: Los lectores de pantalla pueden acceder al contenido, pero usuarios
   videntes no lo ven. */
.sr-only {
  position: absolute;
  width: 1px;
  height: 1px;
  padding: 0;
  margin: -1px;
  overflow: hidden;
  clip: rect(0, 0, 0, 0);
  white-space: nowrap;
  border-width: 0;
}

.hidden {
  display: none;
}
