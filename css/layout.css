/* ============================================================================
   LAYOUT.CSS - Structural Foundation with CSS Grid & Flexbox
   
   WHY: This file establishes the fundamental page structure and reusable layout
   utilities. By separating layout logic from visual styling, we can change
   colors/fonts without breaking the structure.
   
   HOW: We use CSS Grid for the overall page layout (header, main, footer) and
   Flexbox for component-level alignment (centering, distribution).
   
   RESULT: A robust, flexible foundation that adapts to content changes.
   ============================================================================ */

/* WHY: The body is the root container for all visible content. Setting specific
   font and color properties here ensures consistency across the entire page.
   
   HOW: All child elements inherit these values unless explicitly overridden.
   We're establishing our baseline typography and color scheme.
   
   RESULT: Every text element defaults to white text on a dark background with
   the system font stack, creating immediate consistency. */
body {
  font-family: var(--font-primary);
  background-color: var(--color-bg-primary);
  color: var(--color-text-main);
  font-size: var(--font-size-base);
  font-weight: var(--font-weight-normal);
  
  /* WHY: We disable text selection on the body to prevent awkward blue highlights
     when users accidentally drag across navigation or UI elements. However, actual
     content areas (like paragraphs) should re-enable this.
     
     HOW: user-select: none prevents the cursor from selecting text.
     
     RESULT: Cleaner UI interaction, though we'll re-enable selection for readable
     content sections. */
  -webkit-user-select: none;
  -moz-user-select: none;
  user-select: none;
}

/* WHY: Main content areas should allow text selection for copying important info.
   We override the body's user-select: none specifically for main content.
   
   HOW: The main element represents the primary content of the page.
   
   RESULT: Users can select and copy actual content, but not UI chrome. */
main {
  -webkit-user-select: text;
  -moz-user-select: text;
  user-select: text;
}

/* ============================================================================
   CONTAINER SYSTEM
   
   WHY: Wide screens (like 27" monitors) make reading uncomfortable if text
   stretches across the entire width. Optimal line length is 50-75 characters.
   
   HOW: We create container classes that constrain content width and center it.
   ============================================================================ */

/* WHY: A max-width of 1200px ensures content doesn't become too wide on large
   monitors, while margin: 0 auto centers the container horizontally.
   
   HOW: margin: 0 auto applies 0 margin top/bottom and "auto" left/right. When
   left and right margins are both auto, they split the available space equally,
   centering the element.
   
   RESULT: Content is centered and never exceeds 1200px width, maintaining
   readability on all screen sizes. */
.container {
  max-width: 1200px;
  margin: 0 auto;
  /* WHY: Padding prevents content from touching screen edges on smaller devices.
     Without this, text would slam against the edges of phones/tablets.
     
     HOW: var(--spacing-md) applies our 24px padding on left/right sides.
     
     RESULT: Content has breathing room on all devices. */
  padding-left: var(--spacing-md);
  padding-right: var(--spacing-md);
}

/* WHY: Some sections need to span the full width (like full-bleed images or
   background colors) even if their content is contained.
   
   HOW: width: 100% explicitly makes the element fill its parent container.
   
   RESULT: Full-width sections for dramatic visual impact. */
.container-fluid {
  width: 100%;
  padding-left: var(--spacing-md);
  padding-right: var(--spacing-md);
}

/* ============================================================================
   FLEXBOX UTILITIES
   
   WHY: Flexbox is the most efficient way to align items in a single direction
   (horizontally or vertically). These utility classes eliminate repetitive code.
   
   HOW: We create reusable classes that apply common flexbox patterns.
   ============================================================================ */

/* WHY: Centering content (both horizontally and vertically) is extremely common
   in web design - hero sections, cards, modals, etc.
   
   HOW: display: flex activates flexbox. justify-content: center centers children
   along the main axis (horizontal by default), and align-items: center does the
   same for the cross axis (vertical).
   
   RESULT: Perfect centering with just one class, no margin calculations needed. */
.flex-center {
  display: flex;
  justify-content: center;
  align-items: center;
}

/* WHY: Navigation bars typically have content split between left and right
   (logo on left, menu on right).
   
   HOW: space-between distributes children so the first item is at the start,
   the last item is at the end, and remaining space is evenly distributed between.
   
   RESULT: Automatic spacing that adapts to content size - perfect for headers. */
.flex-between {
  display: flex;
  justify-content: space-between;
  align-items: center;
}

/* WHY: Sometimes we want items evenly spaced with space on the sides too,
   like a set of evenly distributed buttons.
   
   HOW: space-around gives each item equal space on both sides, creating even
   distribution including the edges.
   
   RESULT: Visually balanced spacing across the entire container. */
.flex-around {
  display: flex;
  justify-content: space-around;
  align-items: center;
}

/* WHY: Vertical layouts (like sidebars or stacked cards) need flex-direction: column.
   Without this, flex defaults to horizontal row layout.
   
   HOW: flex-direction: column makes the main axis vertical instead of horizontal.
   
   RESULT: Items stack top-to-bottom instead of left-to-right. */
.flex-column {
  display: flex;
  flex-direction: column;
}

/* ============================================================================
   CSS GRID UTILITIES
   
   WHY: CSS Grid is superior for two-dimensional layouts (rows AND columns
   simultaneously). It's perfect for overall page structure.
   
   HOW: We define grid templates that create predictable layouts.
   ============================================================================ */

/* WHY: A standard 12-column grid provides flexibility for complex layouts while
   maintaining alignment. It's divisible by 2, 3, 4, and 6, making it versatile.
   
   HOW: repeat(12, 1fr) creates 12 equal-width columns. "fr" stands for "fraction"
   and distributes available space proportionally.
   
   RESULT: A flexible grid that can accommodate any layout combination (6+6 columns,
   4+4+4, 3+3+3+3, etc.). */
.grid-12 {
  display: grid;
  grid-template-columns: repeat(12, 1fr);
  gap: var(--spacing-md);
}

/* WHY: Many layouts need equal columns (like a 3-column feature section).
   
   HOW: repeat(3, 1fr) creates 3 columns of equal width. auto-fit allows columns
   to wrap to the next row if the container is too narrow.
   
   RESULT: Responsive columns that automatically adjust to available space. */
.grid-auto {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
  gap: var(--spacing-lg);
}

/* ============================================================================
   POSITIONING & Z-INDEX
   
   WHY: Certain elements (navigation, sidebar) need to stay in place while the
   user scrolls. We also need a clear stacking order for overlapping elements.
   ============================================================================ */

/* WHY: Headers typically need to stay visible while scrolling (sticky navigation),
   but for this design we want it to overlay the hero image.
   
   HOW: position: relative establishes a positioning context for absolute children.
   z-index ensures the header stays on top of other content.
   
   RESULT: The header provides a reference point for absolutely positioned children
   and maintains proper stacking order. */
.relative {
  position: relative;
}

/* WHY: Fixed elements stay in the same position relative to the viewport, even
   when scrolling. This is essential for sidebars and sticky navigation.
   
   HOW: position: fixed removes the element from normal document flow and positions
   it relative to the viewport.
   
   RESULT: Elements that follow the user as they scroll, maintaining visibility. */
.fixed {
  position: fixed;
}

/* ============================================================================
   SPACING UTILITIES
   
   WHY: Quick spacing adjustments without writing custom CSS for every element.
   These utilities follow our 8px spacing system.
   ============================================================================ */

/* WHY: Vertical spacing between sections is crucial for visual rhythm. Different
   section types need different spacing amounts.
   
   HOW: We create utility classes for common spacing needs, using our spacing
   scale variables for consistency.
   
   RESULT: Consistent vertical rhythm throughout the page without custom classes. */
.section-spacing {
  padding-top: var(--spacing-2xl);
  padding-bottom: var(--spacing-2xl);
}

.mt-lg {
  margin-top: var(--spacing-lg);
}

.mb-lg {
  margin-bottom: var(--spacing-lg);
}

.my-lg {
  margin-top: var(--spacing-lg);
  margin-bottom: var(--spacing-lg);
}

/* ============================================================================
   TEXT UTILITIES
   
   WHY: Common text alignments are used throughout the design. Creating utilities
   reduces repetition and keeps HTML semantic.
   ============================================================================ */

/* WHY: Different content types need different alignment - headings often center,
   body text aligns left, numbers align right.
   
   HOW: text-align is a simple CSS property that controls horizontal alignment.
   
   RESULT: Quick alignment control without inline styles or custom classes. */
.text-center {
  text-align: center;
}

.text-left {
  text-align: left;
}

.text-right {
  text-align: right;
}

/* WHY: Some sections need white text even if other styles would override it.
   
   HOW: The !important flag ensures this color takes precedence over other styles.
   (Note: Use sparingly! Only for genuine utility classes.)
   
   RESULT: Guaranteed white text when needed, regardless of cascading styles. */
.text-white {
  color: var(--color-text-main) !important;
}

/* WHY: Secondary information (captions, metadata) should be visually de-emphasized
   to create hierarchy.
   
   HOW: Using our muted text color (blue-gray) reduces visual weight.
   
   RESULT: Clear distinction between primary and secondary information. */
.text-muted {
  color: var(--color-text-muted);
}

/* ============================================================================
   VISIBILITY UTILITIES
   
   WHY: Responsive design often requires hiding elements at certain screen sizes.
   
   HOW: display: none removes the element from layout entirely (no space reserved).
   
   RESULT: Clean conditional visibility without JavaScript.
   ============================================================================ */

/* WHY: Sometimes we need to hide content visually but keep it accessible to
   screen readers (like icon labels or skip navigation links).
   
   HOW: This technique clips the element to 1x1 pixel, positions it off-screen,
   and hides overflow, making it invisible but still in the DOM.
   
   RESULT: Screen readers can access the content, but sighted users don't see it. */
.sr-only {
  position: absolute;
  width: 1px;
  height: 1px;
  padding: 0;
  margin: -1px;
  overflow: hidden;
  clip: rect(0, 0, 0, 0);
  white-space: nowrap;
  border-width: 0;
}

.hidden {
  display: none;
}

